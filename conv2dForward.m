function h = conv2dForward(x, W, b, padded)%CONV2DFORWARD Compute 2d convolutional forward pass% Input Arguments:%   'x'         - Input activations (2d, 3d, or 4d matrix) where%                   dimension 1 is data along the y axis%                   dimension 2 is data along the x axis%                   dimension 3 is input channels%                   dimension 4 is is batches%   'W'         - 4d weight matrix%   'b'         - Bias vector%   'padded'    - (optional, default=false) Boolean - whether to zero-pad %                 input so that output x / y dimensions match x.% Return Values:%   'h'         - Layer activationsn = size(W,3);  % number of incoming channelsm = size(W,4);  % number of outgoing channelsbatches = size(x,4);assert(size(x,3) == n);assert(length(b) == m);if (nargin < 4)    % Defaults to shape = 'valid' for convolution    padded = false;end% Determine output shapeif padded    shape = 'same';    sz = [size(x,1), size(x,2), m, batches];else    shape = 'valid';    sz = [size(x,1)-size(W,1)+1, size(x,2)-size(W,2)+1, m, batches];end% Based on my (trivial) benchmarks, conv2(x, rot90(W,2),__) is ~15%% faster than filter2(W, x, __)W = rot90(W,2);h = ones(sz) .* reshape(b, [1,1,m]);for k = 1:batches    for j = 1:m        for i = 1:n            h(:,:,j,k) = h(:,:,j,k) + conv2(x(:,:,i,k), W(:,:,i,j), shape);        end    endend    