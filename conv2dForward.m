function h = conv2dForward(x, W, b, padded)%CONV2DFORWARD Compute 2d convolutional forward pass% Input Arguments:%   'x'         - Input activations%   'W'         - 4d weight matrix%   'b'         - Bias vector%   'padded'    - (optional, default=false) Boolean - whether to zero-pad %                 input so that output x / y dimensions match x.% Return Values:%   'h'         - Layer activations        n = size(W,3);  % number of incoming channels    m = size(W,4);  % number of outgoing channels    assert(size(x,3) == n);    assert(length(b) == m);        if (nargin < 4)        % Defaults to shape = 'valid' for convolution        padded = false;    end        % Determine output shape    if padded        shape = 'same';        sz = [size(x,1), size(x,2), m];    else        shape = 'valid';        sz = [size(x,1)-size(W,1), size(x,2)-size(W,2), m-1]+1;    end        % Based on my (trivial) benchmarks, conv2(x, rot90(W,2),__) is ~15%    % faster than filter2(W, x, __)    W = rot90(W,2);    h = ones(sz) .* reshape(b, [1,1,m]);    for j = 1:m        for i = 1:n            h(:,:,j) = h(:,:,j) + conv2(x(:,:,i), W(:,:,i,j), shape);        end    end    